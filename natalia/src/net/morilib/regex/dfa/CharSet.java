/*
 * Generated By Nina graphical editor.
 */
/* @nina-version: 0.4.10.432 */
package net.morilib.regex.dfa;

import java.io.IOException;

import net.morilib.range.CharSetException;
import net.morilib.range.CharSets;
import net.morilib.range.Range;
import net.morilib.range.integer.IntCharSets;
import net.morilib.range.integer.IntInterval;
import net.morilib.range.integer.IntRange;
import net.morilib.unicode.UnicodeUtils;

/**
 *  
 */
@SuppressWarnings("unused")
public  class CharSet   {

	/* @@@-PARSER-CODE-START-@@@ */
	static class TokenException extends RuntimeException {
	}

	static abstract class Engine {
		abstract int step(int c) throws java.io.IOException;
		abstract boolean accepted();
		abstract boolean isDead();
		abstract boolean isEmptyTransition();
		abstract int execaction(int c);
		abstract boolean isend();
		abstract int recover(Exception e);
		abstract int deadState();
		abstract int stateSize();
		abstract int finallyState();
	}
	static final int INVALIDTOKEN = 0x7fff7fff;
	private static final int NINA_BEGIN = -2;
	private static final int NINA_EOF = -1;
	private static final int NINA_ACCEPT = -8;
	private static final int NINA_FAIL = -9;
	private static final int NINA_HALT_ACCEPT = -91;
	private static final int NINA_HALT_REJECT = -72;
	private static final int NINA_YIELD = -85;
	private static final int NINA_STACKLEN = 72;
	static final int NINA_DISCARDSTATE = 0x40000000;
	static final int INITIAL = 0;
	static final int INDENT = 1;

	private int STATE;
	private int[] __sts = new int[NINA_STACKLEN];
	private Engine[] __stk = new Engine[NINA_STACKLEN];
	private Object[][] __stv = new Object[NINA_STACKLEN][];
	private int __slen = 0;
	private int unread = -1;

	IntRange _;
	java.util.List<IntRange> _l;
	Object yieldObject;
	Throwable exception;

	StringBuffer $buffer;
	int $int;
	java.math.BigInteger $bigint;
	Number $num;

	java.util.Stack<java.io.Reader> streamStack =
			new java.util.Stack<java.io.Reader>();

	void _initlist() {
		_l = new java.util.ArrayList<IntRange>();
	}

	void _addlist(IntRange x) {
		_l.add(x);
	}


	private int _unreadl = -1;

	void INCLUDE(java.io.Reader rd) {
		streamStack.push(rd);
	}

	void INCLUDE(String name) throws java.io.IOException {
		java.io.InputStream ins;

		ins = new java.io.FileInputStream(name);
		INCLUDE(new java.io.InputStreamReader(ins));
	}

	int _read1l() throws java.io.IOException {
		int c;

		while(streamStack.size() > 0) {
			if((c = streamStack.peek().read()) >= 0) {
				return c;
			} else if(streamStack.size() > 1) {
				streamStack.pop().close();
			} else {
				streamStack.pop();
			}
		}
		return NINA_EOF;
	}

	int _read1() throws java.io.IOException {
		int c;

		if(_unreadl != -1) {
			c = _unreadl;
			_unreadl = -1;
		} else if((c = _read1l()) == '\r' && (c = _read1l()) != '\n') {
			_unreadl = c;
			c = '\r';
		}
		return c;
	}

	private int _read() throws java.io.IOException {
		int c;

		while(true) {
			if(unread != -1) {

				c = unread;
				unread = -1;
				__logprint("Read unread: ", c);
			} else if((c = _read1()) != -1) {
				__logprint("Read: ", c);
			} else {
				__logprint("Read end-of-file");
			}
			return c;
		}
	}

	void UNGET(int c) {
		unread = c;
		__logprint("Set unread: ", c);
	}

	void __sleep(int m) {
		try {
			Thread.sleep(m);
		} catch(InterruptedException e) {
			throw new RuntimeException(e);
		}
	}

	private void __logprint(String s, int c) {
	}

	private void __logopen() {
	}

	private void __logprint(String s) {
	}

	private void __logclose() {
	}

	private void __puttrace() {
	}


	private int unit_step(int  $c)  throws java.io.IOException {
		switch(STATE) {
		case 0:
			if($c < 0) {
				STATE = 1;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 1;
				return 1;
			}
		case 1:
			if(($c == '\\')) {
				STATE = 2;
				return 1;
			} else if(($c == '[')) {
				STATE = 3;
				return 1;
			} else if($c >= 0) {
				STATE = 4;
				return 1;
			}
			return 0;
		case 4:
			if(($c == '-')) {
				STATE = 5;
				return 1;
			} else if($c < 0) {
				STATE = 6;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 6;
				return 1;
			}
		case 6:
			return 0;
		case 5:
			if(($c == '\\')) {
				STATE = 7;
				return 1;
			} else if($c >= 0) {
				STATE = 8;
				return 1;
			}
			return 0;
		case 8:
			return 0;
		case 7:
			if(($c == 'x')) {
				STATE = 9;
				return 1;
			} else if(($c == 'n') || ($c == 'r') || ($c == 't')) {
				STATE = 10;
				return 1;
			} else if(($c == 'u')) {
				STATE = 11;
				return 1;
			} else if($c >= 0) {
				STATE = 8;
				return 1;
			}
			return 0;
		case 11:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer = new StringBuffer();$buffer.append((char)$c);
				STATE = 12;
				return 1;
			}
			return 0;
		case 12:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer.append((char)$c);
				STATE = 13;
				return 1;
			} else if($c < 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 14;
				return 1;
			} else if($c >= 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 14;
				return 1;
			}
		case 14:
			return 0;
		case 13:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer.append((char)$c);
				STATE = 15;
				return 1;
			} else if($c < 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 14;
				return 1;
			} else if($c >= 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 14;
				return 1;
			}
		case 15:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer.append((char)$c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 14;
				return 1;
			} else if($c < 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 14;
				return 1;
			} else if($c >= 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 14;
				return 1;
			}
		case 10:
			return 0;
		case 9:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer = new StringBuffer();$buffer.append((char)$c);
				STATE = 16;
				return 1;
			}
			return 0;
		case 16:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer.append((char)$c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 17;
				return 1;
			} else if($c < 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 17;
				return 1;
			} else if($c >= 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 17;
				return 1;
			}
		case 17:
			return 0;
		case 3:
				STATE = 18;
				return 1;
		case 18:
			if($c >= 0) {
				__stkpush(19, ENGINE_charSet);
				STATE = 0;
				return NINA_ACCEPT;
			}
			return 0;
		case 19:
			if(($c == ']')) {
				STATE = 20;
				return 1;
			}
			return 0;
		case 20:
			return 0;
		case 2:
			if(($c == 'n') || ($c == 'r') || ($c == 't')) {
				STATE = 21;
				return 1;
			} else if(($c == 'P') || ($c == 'p')) {
				STATE = 22;
				return 1;
			} else if(($c == 'D') || ($c == 'S') || ($c == 'W') || ($c == 'd') || ($c == 's') || ($c == 'w')) {
				STATE = 23;
				return 1;
			} else if(($c == 'x')) {
				STATE = 24;
				return 1;
			} else if(($c == 'u')) {
				STATE = 25;
				return 1;
			} else if($c >= 0) {
				STATE = 4;
				return 1;
			}
			return 0;
		case 25:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer = new StringBuffer();$buffer.append((char)$c);
				STATE = 26;
				return 1;
			}
			return 0;
		case 26:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer.append((char)$c);
				STATE = 27;
				return 1;
			} else if($c < 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 28;
				return 1;
			} else if($c >= 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 28;
				return 1;
			}
		case 28:
			if(($c == '-')) {
				STATE = 5;
				return 1;
			} else if($c < 0) {
				STATE = 6;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 6;
				return 1;
			}
		case 27:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer.append((char)$c);
				STATE = 29;
				return 1;
			} else if($c < 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 28;
				return 1;
			} else if($c >= 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 28;
				return 1;
			}
		case 29:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer.append((char)$c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 28;
				return 1;
			} else if($c < 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 28;
				return 1;
			} else if($c >= 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 28;
				return 1;
			}
		case 24:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer = new StringBuffer();$buffer.append((char)$c);
				STATE = 30;
				return 1;
			}
			return 0;
		case 30:
			if(($c >= '0' && $c <= '9') || ($c >= 'A' && $c <= 'F') || ($c >= 'a' && $c <= 'f')) {
				$buffer.append((char)$c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 31;
				return 1;
			} else if($c < 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 31;
				return 1;
			} else if($c >= 0) {
				UNGET($c);$int=Integer.parseInt($buffer.toString(), 16);
				STATE = 31;
				return 1;
			}
		case 31:
			if(($c == '-')) {
				STATE = 5;
				return 1;
			} else if($c < 0) {
				STATE = 6;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 6;
				return 1;
			}
		case 23:
			return 0;
		case 22:
			if(($c == '{')) {
				STATE = 32;
				return 1;
			}
			return 0;
		case 32:
			if(($c == '}')) {
				STATE = 33;
				return 1;
			} else if($c >= 0) {
				STATE = 34;
				return 1;
			}
			return 0;
		case 34:
			if(($c == '}')) {
				STATE = 33;
				return 1;
			} else if($c >= 0) {
				STATE = 34;
				return 1;
			}
			return 0;
		case 33:
			return 0;
		case 21:
			if(($c == '-')) {
				STATE = 5;
				return 1;
			} else if($c < 0) {
				STATE = 6;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 6;
				return 1;
			}
		}
		return 0;
	}

	private boolean unit_accepted() {
		return (STATE == 17 ||
				STATE == 33 ||
				STATE == 20 ||
				STATE == 23 ||
				STATE == 6 ||
				STATE == 8 ||
				STATE == 10 ||
				STATE == 14);
	}

	int unit_execaction(int  $c) {
		switch(STATE) {
		case 6:
			// State63         
			_ = rng(cb, cb);
			break;
		case 31:
			// esc7      
			cb = $int;
			break;
		case 14:
			// esc14             
			_ = rng(cb, $int);
			break;
		case 7:
			// esc11   
			// none
			break;
		case 12:
			break;
		case 17:
			// esc15             
			_ = rng(cb, $int);
			break;
		case 18:
			break;
		case 4:
			// State59   
			cb = $c;
			break;
		case 25:
			// esc3   
			// none
			break;
		case 26:
			break;
		case 21:
			// State65      
			cb = ecd($c);
			break;
		case 3:
			// anom2   
			// none
			break;
		case 24:
			// esc4   
			// none
			break;
		case 27:
			break;
		case 29:
			break;
		case 5:
			// State61   
			// none
			break;
		case 23:
			// esc2        
			_ = esc($c);
			break;
		case 10:
			// State66              
			_ = rng(cb, ecd($c));
			break;
		case 34:
			// esc10              
			b.append((char)$c);
			break;
		case 9:
			// esc12   
			// none
			break;
		case 19:
			break;
		case 28:
			// esc6      
			cb = $int;
			break;
		case 33:
			// esc9                       
			_ = prop(rn, b.toString());
			break;
		case 0:
			break;
		case 30:
			break;
		case 11:
			// esc13   
			// none
			break;
		case 8:
			// State62         
			_ = rng(cb, $c);
			break;
		case 15:
			break;
		case 2:
			// esc1   
			// none
			break;
		case 16:
			break;
		case 20:
			// blocend   
			// none
			break;
		case 1:
			// State57   
			// none
			break;
		case 22:
			// esc5    
			rn = $c;
			break;
		case 32:
			// esc8                    
			b = new StringBuilder();
			break;
		case 13:
			break;
		}
		return 1;
	}

	boolean unit_isend() {
		return (STATE == 0 ||
				STATE == 3 ||
				STATE == 4 ||
				STATE == 12 ||
				STATE == 13 ||
				STATE == 15 ||
				STATE == 16 ||
				STATE == 21 ||
				STATE == 27 ||
				STATE == 26 ||
				STATE == 29 ||
				STATE == 28 ||
				STATE == 31 ||
				STATE == 30);
	}

	private final Engine ENGINE_unit = new Engine() {

		int step(int c) throws java.io.IOException {
			return unit_step(c);
		}

		boolean accepted() {
			return unit_accepted();
		}

		int execaction(int c) {
			return unit_execaction(c);
		}

		boolean isend() {
			return unit_isend();
		}

		int recover(Exception e) {
			return -1;
		}

		int deadState() {
			return -1;
		}

		int stateSize() {
			return 35;
		}

		int finallyState() {
			return -1;
		}

		boolean isDead() {
		return (STATE == 17 ||
				STATE == 33 ||
				STATE == 20 ||
				STATE == 23 ||
				STATE == 6 ||
				STATE == 8 ||
				STATE == 10 ||
				STATE == 14);
		}

		boolean isEmptyTransition() {
		return (STATE == 3);
		}

		public String toString() {
			return "unit";
		}

	};

	private int or_step(int  $c)  throws java.io.IOException {
		switch(STATE) {
		case 0:
			if($c < 0) {
				STATE = 1;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 1;
				return 1;
			}
		case 1:
			if($c >= 0) {
				__stkpush(2, ENGINE_unit);
				STATE = 0;
				return NINA_ACCEPT;
			}
			return 0;
		case 2:
				STATE = 3;
				return 1;
		case 3:
			if(($c >= ' ' && $c <= '%') || ($c >= '\'' && $c <= '\\') || ($c >= '^' && $c <= 2147483647)) {
				UNGET($c);
				STATE = 4;
				return 1;
			}
			return 0;
		case 4:
			if($c >= 0) {
				__stkpush(5, ENGINE_unit);
				STATE = 0;
				return NINA_ACCEPT;
			}
			return 0;
		case 5:
				STATE = 6;
				return 1;
		case 6:
			if(($c >= ' ' && $c <= '%') || ($c >= '\'' && $c <= '\\') || ($c >= '^' && $c <= 2147483647)) {
				UNGET($c);
				STATE = 4;
				return 1;
			}
			return 0;
		}
		return 0;
	}

	private boolean or_accepted() {
		return (STATE == 3 ||
				STATE == 6);
	}

	int or_execaction(int  $c) {
		switch(STATE) {
		case 6:
			// State6                             
			(__stv[__slen - 1][3]) = _ = or(((IntRange)(__stv[__slen - 1][3])), _);
			break;
		case 1:
			break;
		case 4:
			break;
		case 3:
			// firstOr          
			(__stv[__slen - 1][3]) = _;
			break;
		case 0:
			break;
		case 2:
			break;
		case 5:
			break;
		}
		return 1;
	}

	boolean or_isend() {
		return (STATE == 0 ||
				STATE == 2 ||
				STATE == 5);
	}

	private final Engine ENGINE_or = new Engine() {

		int step(int c) throws java.io.IOException {
			return or_step(c);
		}

		boolean accepted() {
			return or_accepted();
		}

		int execaction(int c) {
			return or_execaction(c);
		}

		boolean isend() {
			return or_isend();
		}

		int recover(Exception e) {
			return -1;
		}

		int deadState() {
			return -1;
		}

		int stateSize() {
			return 7;
		}

		int finallyState() {
			return -1;
		}

		boolean isDead() {
		return false;
		}

		boolean isEmptyTransition() {
		return (STATE == 2 ||
				STATE == 5);
		}

		public String toString() {
			return "or";
		}

	};

	private int set_step(int  $c)  throws java.io.IOException {
		switch(STATE) {
		case 0:
			if($c < 0) {
				STATE = 1;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 1;
				return 1;
			}
		case 1:
			if($c >= 0) {
				__stkpush(2, ENGINE_or);
				STATE = 0;
				return NINA_ACCEPT;
			}
			return 0;
		case 2:
				STATE = 3;
				return 1;
		case 3:
			if(($c == '&')) {
				STATE = 4;
				return 1;
			}
			return 0;
		case 4:
			if($c >= 0) {
				__stkpush(5, ENGINE_or);
				STATE = 0;
				return NINA_ACCEPT;
			}
			return 0;
		case 5:
				STATE = 6;
				return 1;
		case 6:
			if(($c == '&')) {
				STATE = 4;
				return 1;
			}
			return 0;
		}
		return 0;
	}

	private boolean set_accepted() {
		return (STATE == 3 ||
				STATE == 6);
	}

	int set_execaction(int  $c) {
		switch(STATE) {
		case 0:
			break;
		case 2:
			break;
		case 4:
			break;
		case 1:
			break;
		case 3:
			// firstAnd          
			(__stv[__slen - 1][3]) = _;
			break;
		case 5:
			break;
		case 6:
			// State3                                
			(__stv[__slen - 1][3]) = _ = and(((IntRange)(__stv[__slen - 1][3])), _);
			break;
		}
		return 1;
	}

	boolean set_isend() {
		return (STATE == 0 ||
				STATE == 2 ||
				STATE == 5);
	}

	private final Engine ENGINE_set = new Engine() {

		int step(int c) throws java.io.IOException {
			return set_step(c);
		}

		boolean accepted() {
			return set_accepted();
		}

		int execaction(int c) {
			return set_execaction(c);
		}

		boolean isend() {
			return set_isend();
		}

		int recover(Exception e) {
			return -1;
		}

		int deadState() {
			return -1;
		}

		int stateSize() {
			return 7;
		}

		int finallyState() {
			return -1;
		}

		boolean isDead() {
		return false;
		}

		boolean isEmptyTransition() {
		return (STATE == 2 ||
				STATE == 5);
		}

		public String toString() {
			return "set";
		}

	};

	private int charSet_step(int  $c)  throws java.io.IOException {
		switch(STATE) {
		case 0:
			if($c < 0) {
				STATE = 1;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 1;
				return 1;
			}
		case 1:
			if(($c == '^')) {
				STATE = 2;
				return 1;
			} else if($c < 0) {
				STATE = 3;
				return 1;
			} else if($c >= 0) {
				UNGET($c);
				STATE = 3;
				return 1;
			}
		case 3:
			if($c >= 0) {
				__stkpush(4, ENGINE_set);
				STATE = 0;
				return NINA_ACCEPT;
			}
			return 0;
		case 4:
				STATE = 5;
				return 1;
		case 5:
			return 0;
		case 2:
				STATE = 3;
				return 1;
		}
		return 0;
	}

	private boolean charSet_accepted() {
		return (STATE == 5);
	}

	int charSet_execaction(int  $c) {
		switch(STATE) {
		case 4:
			break;
		case 0:
			break;
		case 3:
			break;
		case 2:
			// comp3          
			(__stv[__slen - 1][1]) = true;
			break;
		case 5:
			// State56              
			_ = bloc(_, ((Boolean)(__stv[__slen - 1][1])));
			break;
		case 1:
			// comp         
			(__stv[__slen - 1][1]) = false;
			break;
		}
		return 1;
	}

	boolean charSet_isend() {
		return (STATE == 0 ||
				STATE == 1 ||
				STATE == 2 ||
				STATE == 4);
	}

	private final Engine ENGINE_charSet = new Engine() {

		int step(int c) throws java.io.IOException {
			return charSet_step(c);
		}

		boolean accepted() {
			return charSet_accepted();
		}

		int execaction(int c) {
			return charSet_execaction(c);
		}

		boolean isend() {
			return charSet_isend();
		}

		int recover(Exception e) {
			return -1;
		}

		int deadState() {
			return -1;
		}

		int stateSize() {
			return 6;
		}

		int finallyState() {
			return -1;
		}

		boolean isDead() {
		return (STATE == 5);
		}

		boolean isEmptyTransition() {
		return (STATE == 2 ||
				STATE == 4);
		}

		public String toString() {
			return "charSet";
		}

	};

	void __stkpush(int st, Engine en) {
		Object[][] c;
		Engine[] b;
		int[] a;

		if(__slen >= __sts.length) {
			a = new int[__sts.length * 2];
			b = new Engine[__stk.length * 2];
			c = new Object[__stk.length * 2][];
			System.arraycopy(__sts, 0, a, 0, __sts.length);
			System.arraycopy(__stk, 0, b, 0, __stk.length);
			System.arraycopy(__stv, 0, c, 0, __stv.length);
			__sts = a;
			__stk = b;
			__stv = c;
		}
		__sts[__slen] = st;
		__stk[__slen] = en;
		__stv[__slen++] = new Object[en.stateSize()];
	}

	private int _parse(int x, Boolean rt, boolean skip,
			int[] st) throws java.io.IOException {
		boolean b = false, p = skip;
		int c = x;
		Engine en;
		int a;

		b = __stk[__slen - 1].accepted();
		if(rt.booleanValue()) {
			switch(__stk[__slen - 1].execaction(NINA_BEGIN)) {
			case NINA_ACCEPT:
				__logprint("accept " + __stk[__slen - 1]);
				st[0] = NINA_ACCEPT;  return -1;
			case NINA_FAIL:
				__logprint("match failed: begin");
				__puttrace();
				st[0] = NINA_FAIL;  return -1;
			case NINA_HALT_ACCEPT:
				__logprint("machine halted: begin");
				st[0] = NINA_HALT_ACCEPT;  return -1;
			case NINA_HALT_REJECT:
				__logprint("machine halted: begin");
				st[0] = NINA_HALT_REJECT;  return -1;
			case NINA_YIELD:
				__logprint("machine yielded: ", c);
				st[0] = NINA_YIELD;  return -1;
			}
		}

		try {
			do {
				en = __stk[__slen - 1];
				if(p) {
					p = false;
				} else if((a = en.step(c)) > 0) {
					__logprint("transit to state " + STATE + ": ", c);
					b = en.accepted();
					switch(en.execaction(c)) {
					case NINA_ACCEPT:
						__logprint("accept " + __stk[__slen - 1]);
						UNGET(c);
						st[0] = NINA_ACCEPT;  return -1;
					case NINA_FAIL:
						__logprint("match failed: ", c);
						__puttrace();
						UNGET(c);
						st[0] = NINA_FAIL;  return -1;
					case NINA_HALT_ACCEPT:
						__logprint("machine halted: ", c);
						st[0] = NINA_HALT_ACCEPT;  return -1;
					case NINA_HALT_REJECT:
						__logprint("machine halted: ", c);
						st[0] = NINA_HALT_REJECT;  return -1;
					case NINA_YIELD:
						__logprint("machine yielded: ", c);
						st[0] = NINA_YIELD;  return -1;
					}
				} else if(a < 0) {
					__logprint("entering " + __stk[__slen - 1]);
					return c;
				} else if(b) {
					__logprint("accept " + __stk[__slen - 1]);
					UNGET(c);
					st[0] = NINA_ACCEPT;  return -1;
				} else if(c == -1) {
					if(!b)  throw new TokenException();
					st[0] = NINA_ACCEPT;  return -1;
				} else {
					__logprint("match failed: ", c);
					__puttrace();
					UNGET(c);
					st[0] = NINA_FAIL;  return -1;
				}

				if(__stk[__slen - 1].isEmptyTransition()) {
					// do nothing
				} else if(!__stk[__slen - 1].isDead()) {
					c = _read();
				} else if(b) {
					__logprint("accept " + __stk[__slen - 1]);
					st[0] = NINA_ACCEPT;  return -1;
				} else {
					__logprint("match failed: ", c);
					__puttrace();
					st[0] = NINA_FAIL;  return -1;
				}
			} while(true);
		} catch(RuntimeException e) {
			UNGET(c);
			throw e;
		}
	}

	private Boolean execfinally() {
		int a, b;

		if((a = __stk[__slen - 1].finallyState()) >= 0) {
			b = STATE;  STATE = a;
			switch(__stk[__slen - 1].execaction(NINA_BEGIN)) {
			case NINA_HALT_ACCEPT:
				__slen = 0;
				return Boolean.TRUE;
			case NINA_HALT_REJECT:
				__slen = 0;
				return Boolean.FALSE;
			}
			STATE = b;
		}
		return null;
	}

	private int getdeadstate() {
		return __stk[__slen - 1].deadState();
	}

	private int getrecover(Exception e) {
		return __stk[__slen - 1].recover(e);
	}

	boolean parse(Engine entry) throws java.io.IOException {
		Boolean b = Boolean.FALSE;
		int[] a = new int[1];
		boolean skip = true;
		int c = 0;

		__logopen();
		try {
			if(__slen == 0) {
				b = Boolean.TRUE;
				__stkpush(0, entry);
			}

			ot: while(true) {
				try {
					if((c = _parse(c, b, skip, a)) != -1) {
						skip = false;
					} else if(a[0] == NINA_FAIL) {
						while((STATE = getdeadstate()) < 0) {
							if((b = execfinally()) != null)  break ot;
							if(__slen-- <= 1) {
								throw new TokenException();
							}
						}
						skip = true;
					} else if(a[0] == NINA_HALT_ACCEPT) {
						if((b = execfinally()) != null)  break;
						__slen = 0;
						b = Boolean.TRUE;  break;
					} else if(a[0] == NINA_HALT_REJECT) {
						if((b = execfinally()) != null)  break;
						__slen = 0;
						b = Boolean.FALSE;  break;
					} else if(a[0] == NINA_YIELD) {
						return false;
					} else if(__slen > 1) {
						if((b = execfinally()) != null)  break;
						STATE = __sts[--__slen];
						skip = true;
					} else {
						if((b = execfinally()) != null)  break;
						b = new Boolean(__stk[--__slen].accepted());
						break;
					}
				} catch(RuntimeException e) {
					exception = e;
					if(__slen <= 0)  throw e;
					while((STATE = getrecover(e)) < 0) {
						if((b = execfinally()) != null)  return b;
						if(__slen-- <= 1)  throw e;
					}
				}
				b = Boolean.TRUE;
			}
			if(!b.booleanValue())  throw new TokenException();
			return b.booleanValue();
		} finally {
			__logclose();
		}
	}

	boolean parse(java.io.Reader rd) throws java.io.IOException {
		streamStack.push(rd);
		return parse(ENGINE_charSet);
	}

	static boolean parseAll(java.io.Reader rd) throws java.io.IOException {
		CharSet o = new CharSet();

		return o.parse(rd);
	}

	void setStream(java.io.Reader rd) {
		if(streamStack.size() == 0) {
			throw new IllegalStateException();
		}
		yieldObject = rd;
		streamStack.push(rd);
	}

	Object parseNext() throws java.io.IOException {
		Object o;

		if(streamStack.size() == 0) {
			throw new IllegalStateException();
		} else if(yieldObject == null) {
			return null;
		} else if(parse(ENGINE_charSet)) {
			if(yieldObject == null)  throw new NullPointerException();
			o = yieldObject;  yieldObject = null;
			return o;
		} else {
			if(yieldObject == null)  throw new NullPointerException();
			return yieldObject;
		}
	}

	static void puts(String s) {
		System.out.println(s);
	}

	boolean parse(java.io.InputStream rd) throws java.io.IOException {
		return parse(new java.io.InputStreamReader(rd));
	}

	static boolean parseAll(
			java.io.InputStream rd) throws java.io.IOException {
		return parseAll(new java.io.InputStreamReader(rd));
	}

	/* @@@-PARSER-CODE-END-@@@ */
	private StringBuilder b;
	private int rn, cb;

	private IntRange and(IntRange a, IntRange b) {
		return a.meet(b);
	}

	private IntRange or(IntRange a, IntRange b) {
		return a.join(b);
	}

	private IntRange bloc(IntRange a, boolean compl) {
		return compl ? a.complement() : a;
	}

	private IntRange rng(int cb, int ce) {
		return new IntInterval(cb, ce);
	}

	private IntRange esc(int c) {
		switch(c) {
		case 'd':  return IntCharSets.ASCII_NUMBERS;
		case 'D':  return IntCharSets.NOT_ASCII_NUMBERS;
		case 's':  return IntCharSets.ASCII_WHITESPACE;
		case 'S':  return IntCharSets.NOT_ASCII_WHITESPACE;
		case 'w':  return IntCharSets.ASCII_WORD;
		case 'W':  return IntCharSets.NOT_ASCII_WORD;
		default:   throw new RuntimeException();
		}
	}

	private int ecd(int c) {
		switch(c) {
		case 't':  return '\t';
		case 'r':  return '\r';
		case 'n':  return '\n';
		default:   throw new RuntimeException();
		}
	}

	private IntRange prop(int c, String s) {
		IntRange r;

		r = UnicodeUtils.getPropertyIntRange(s);
		if(c == 'P') {
			r = r.complement();
		}
		return r;
	}

	/**
	 * 
	 * @param s
	 * @return
	 */
	public static IntRange parse(String s) {
		CharSet p;

		p = new CharSet();
		try {
			p.parse(new java.io.StringReader(s));
			return p._;
		} catch(TokenException e) {
			throw new CharSetException();
		} catch(IOException e) {
			throw new RuntimeException();
		}
	}

	/**
	 * 
	 * @param s
	 * @return
	 */
	public static Range parseRange(String s) {
		return IntCharSets.toRange(parse(s));
	}

}
